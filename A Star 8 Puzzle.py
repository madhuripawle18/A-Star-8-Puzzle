from typing import List
import copy
import numpy
import sys
sys.setrecursionlimit(100000)


class A_Star:

    i_zero = 0                                  # Stores row value of zero in the state being explored
    j_zero: int = 0                             # Stores column value of zero in the state being explored
    step_cost: int = 0                          # Stores the g(n) value i.e the step cost
    nodes_generated: int = 0                    # Stores the count of total number of nodes generated
    initial_state: List[int] = []               # Stores the state being explored
    initial_state_Copy: List[int] = []          # Stores a copy of initial state to use for different heuristic
    goal_state: List[int] = []                  # Stores the goal state
    unexplored_states: List[list] = []          # Stores all the nodes that are yet to be explored
    unexplored_states_node: List[list] = []     # Stores new nodes that have been generated in exploring_nodes function
    explored_states: List[list] = []            # Stores list of nodes that has been explored
    misplaced_tiles_list: List[int] = []        # Stores f(n) value corresponding to nodes in unexplored_states list
    manhattan_distance_list: List[int] = []     # Stores f(n) value corresponding to nodes in unexplored_states list

    # The following statements are used to ask initial and goal states from user
    print("\nEnter Initial state \n")
    print("Enter 1st row")
    initial_state_Copy.append([int(x) for x in input().split()])
    print("Enter 2nd row")
    initial_state_Copy.append([int(x) for x in input().split()])
    print("Enter 3rd row")
    initial_state_Copy.append([int(x) for x in input().split()])
    print("\nEnter the goal state\n")
    print("Enter 1st row")
    goal_state.append([int(x) for x in input().split()])
    print("Enter 2nd row")
    goal_state.append([int(x) for x in input().split()])
    print("Enter 3rd row")
    goal_state.append([int(x) for x in input().split()])

    # Making a copy to use the initial state for both heuristics separately

    initial_state = copy.deepcopy(initial_state_Copy)

    # The flag helps us to choose the heuristic: 0 being Misplaced Tiles and 1 being Manhattan Distance

    def __init__(self, flag):
        self.flag: int = flag

    # Following function helps in finding the row and column of '0' in the state being explored and
    # also checks if goal state is found.

    def finding_zero(self):

        if A_Star.initial_state == A_Star.goal_state :
            print("\nThe goal state has been reached \n")
            a = numpy.array(A_Star.initial_state)
            print(a.reshape((3, 3)))
            print("\n")
            print("Number of nodes generated ", A_Star.nodes_generated, " nodes \n")
            print("Number of nodes explored ", A_Star.explored_states.__len__(), " nodes \n")

            # Initialises most variables to initial values so as to use for different heuristic

            if self.flag != 1:
                self.flag = 1
                A_Star.i_zero: int = 0
                A_Star.j_zero: int = 0
                A_Star.step_cost: int = 0
                A_Star.nodes_generated: int = 0
                A_Star.explored_states: List[list] = []
                A_Star.unexplored_states: List[list] = []
                A_Star.initial_state = copy.deepcopy(A_Star.initial_state_Copy)
            return 1

        else:
            print("\nThe State to be explored")
            a = numpy.array(A_Star.initial_state)
            print("\n")
            print(a.reshape((3, 3)))
            for i in range(0, 3):
                for j in range(0, 3):
                    if A_Star.initial_state[i][j] == 0:
                        A_Star.i_zero = i
                        A_Star.j_zero = j
                        break

        self.exploring_nodes()

    # Following function finds all the possible nodes that can be generated by
    # swapping the zero with numbers on top,right,bottom and left to create a new node
    # and appends the new node to the unexplored_states list

    def exploring_nodes(self):

        # Creates a new node by swapping zero with number on top of it

        if 3 > A_Star.i_zero - 1 >= 0 and 3 > A_Star.j_zero >= 0:
            new_state = copy.deepcopy(A_Star.initial_state)
            new_state[A_Star.i_zero - 1][A_Star.j_zero], new_state[A_Star.i_zero][A_Star.j_zero] = \
            new_state[A_Star.i_zero][A_Star.j_zero], new_state[A_Star.i_zero - 1][
                A_Star.j_zero]
            if new_state not in A_Star.explored_states:
                A_Star.unexplored_states_node.append(new_state)
                A_Star.nodes_generated = A_Star.nodes_generated + 1

        # Creates a new node by swapping zero with number to the right of it

        if 3 > A_Star.i_zero >= 0 and 3 > A_Star.j_zero + 1 >= 0:
            new_state = copy.deepcopy(A_Star.initial_state)
            new_state[A_Star.i_zero][A_Star.j_zero + 1], new_state[A_Star.i_zero][A_Star.j_zero] = \
            new_state[A_Star.i_zero][A_Star.j_zero], new_state[A_Star.i_zero][
                A_Star.j_zero + 1]
            if new_state not in A_Star.explored_states:
                A_Star.unexplored_states_node.append(new_state)
                A_Star.nodes_generated = A_Star.nodes_generated + 1

        # Creates a new node by swapping zero with number on bottom of it

        if 3 > A_Star.i_zero + 1 >= 0 and 3 > A_Star.j_zero >= 0:
            new_state = copy.deepcopy(A_Star.initial_state)
            new_state[A_Star.i_zero + 1][A_Star.j_zero], new_state[A_Star.i_zero][A_Star.j_zero] = \
            new_state[A_Star.i_zero][A_Star.j_zero], new_state[A_Star.i_zero + 1][A_Star.j_zero]
            if new_state not in A_Star.explored_states:
                A_Star.unexplored_states_node.append(new_state)
                A_Star.nodes_generated = A_Star.nodes_generated + 1

        # Creates a new node by swapping zero with number to the left of it

        if 3 > A_Star.i_zero >= 0 and 3 > A_Star.j_zero - 1 >= 0:
            new_state = copy.deepcopy(A_Star.initial_state)
            new_state[A_Star.i_zero][A_Star.j_zero - 1], new_state[A_Star.i_zero][A_Star.j_zero] = \
            new_state[A_Star.i_zero][A_Star.j_zero], new_state[A_Star.i_zero][
                A_Star.j_zero - 1]
            if new_state not in A_Star.explored_states:
                A_Star.unexplored_states_node.append(new_state)
                A_Star.nodes_generated = A_Star.nodes_generated + 1

        if new_state != A_Star.initial_state:
            A_Star.step_cost = A_Star.step_cost + 1

        if self.flag == 0:
            self.misplaced_tiles()
        elif self.flag == 1:
            self.manhattan_distance()

    # Following function Calculates how many numbers in state being explored
    # are in the wrong position based on the goal state

    def misplaced_tiles(self):
        for k in range(0, len(A_Star.unexplored_states_node)):
            count = 0
            for i in range(0, 3):
                for j in range(0, 3):
                    if A_Star.unexplored_states_node[k][i][j] != A_Star.goal_state[i][j]:
                        if A_Star.unexplored_states_node[k][i][j] != 0:
                            count = count + 1   # h(n) for misplaced tiles heuristic

            A_Star.misplaced_tiles_list.append(A_Star.step_cost + count)  # Adding g(n)+h(n) to the list

        # Adding the new set of unexplored nodes to already present set of unexplored nodes
        A_Star.unexplored_states.extend(A_Star.unexplored_states_node)
        # Emptying the nodes list for the next iteration
        A_Star.unexplored_states_node: list[list] = []
        # Finding the least f(n) value
        A_Star.min_misplaced = A_Star.misplaced_tiles_list.index(min(A_Star.misplaced_tiles_list))
        # Adding the state that has been explored into the explored_states list
        A_Star.explored_states.append(A_Star.initial_state)
        # Making the node with the least f(n) value as the state that has to be explored next
        A_Star.initial_state = A_Star.unexplored_states[A_Star.min_misplaced]
        # Removing the node to be explored from the unexplored_states list
        A_Star.unexplored_states.pop(A_Star.min_misplaced)
        # Removing the corresponding f(n) value from misplaced_tiles_list
        A_Star.misplaced_tiles_list.pop(A_Star.min_misplaced)

        self.finding_zero()

    # Following function Calculates how many steps are needed to reach
    # the actual position in initial state as per the goal state

    def manhattan_distance(self):

        for k in range(0, len(A_Star.unexplored_states_node)):
            distance = 0
            for i in range(0, 3):
                for j in range(0, 3):
                    for gi in range(0, 3):
                        for gj in range(0, 3):
                            if A_Star.unexplored_states_node[k][i][j] == A_Star.goal_state[gi][gj]:
                                if A_Star.unexplored_states_node[k][i][j] != 0:
                                    distance += abs(i - gi) + abs(j - gj)   # h(n) for manhattan distance heuristic

            A_Star.manhattan_distance_list.append(distance + A_Star.step_cost)
        # Adding the new set of unexplored nodes to already present set of unexplored nodes
        A_Star.unexplored_states.extend(A_Star.unexplored_states_node)
        # Emptying the nodes list for the next iteration
        A_Star.unexplored_states_node: list[list] = []
        # Finding the least f(n) value
        A_Star.min_manhattan = A_Star.manhattan_distance_list.index(min(A_Star.manhattan_distance_list))
        # Adding the state that has been explored into the explored_states list
        A_Star.explored_states.append(A_Star.initial_state)
        # Making the node with the least f(n) value as the state that has to be explored next
        A_Star.initial_state = A_Star.unexplored_states[A_Star.min_manhattan]
        # Removing the node to be explored from the unexplored_states list
        A_Star.unexplored_states.pop(A_Star.min_manhattan)
        # Removing the corresponding f(n) value from misplaced_tiles_list
        A_Star.manhattan_distance_list.pop(A_Star.min_manhattan)

        self.finding_zero()


A_Star_1: A_Star = A_Star(0)
print("\n Misplaced Tiles \n")
A_Star_1.finding_zero()
print("\n Manhattan Distance \n")
A_Star_1.finding_zero()